### constructor function for ballgown objects

### a couple helper functions:
.readIntron <- function(file){
    intron <- read.table(file, header=TRUE, sep="\t", colClasses=c("integer", "character", "factor", 
        "integer", "integer", "integer", "integer", "numeric"))
    intron <- intron[order(intron$i_id), ]
    rownames(intron) <- 1:nrow(intron)
    return(intron)
}

.readExon <- function(file) {
    exon <- read.table(file, header=TRUE, sep="\t", colClasses=c("integer", "character", "factor", 
        "integer", "integer", "integer", "integer", "numeric", "numeric", "numeric", "numeric", 
        "numeric"))
    exon <- exon[order(exon$e_id), ]
    rownames(exon) <- 1:nrow(exon)
    return(exon)
}

.readTrans <- function(file) {
    trans <- read.table(file, header=TRUE, sep="\t", colClasses=c("integer", "character", "factor", 
        "integer", "integer", "character", "integer", "integer", "character", "character", 
        "numeric", "numeric"))
    trans <- trans[order(trans$t_id), ]
    rownames(trans) <- 1:nrow(trans)
    return(trans)
}

#' constructor function for ballgown objects
#'
#' @param samples vector of file paths to folders containing sample-specific ballgown data 
#' (generated by \code{tablemaker}).  If \code{samples} is provided, \code{dataDir} and 
#' \code{samplePattern} are not used.
#' @param dataDir file path to top-level directory containing sample-specific folders with ballgown 
#' data in them.  Only used if \code{samples} is NULL.
#' @param samplePattern regular expression identifying the subdirectories of \code{dataDir} 
#' containing data to be loaded into the ballgown object (and only those subdirectories).  Only used
#' if \code{samples} is NULL.
#' @param bamfiles optional vector of file paths to read alignment files for each sample.  If 
#' provided, make sure to sort properly (e.g., in the same order as \code{samples}).  Default NULL.
#' @param pData either a \code{data.frame} with rows corresponding to samples and columns 
#' corresponding to phenotypic variables, or a path to a file containing phenotype data.
#' @param verbose if \code{TRUE}, print status messages and timing information as the object is 
#' constructed.
#' @param ... extra arguments for \code{read.table}, if \code{pData} is a path to a file.
#' 
#' @details Because experimental data is recorded so variably, it is the user's responsibility to 
#' format \code{pData} correctly.  In particular, it's really important that the rows of 
#' \code{pData} (corresponding to samples) are ordered the same way as \code{samples} or the 
#' \code{dataDir}/\code{samplePattern} combo. You can run 
#' \code{file.path(path = dataDir, pattern = samplePattern)} to see the sample order if 
#' \code{samples} was not used.
#' 
#' If you are creating a ballgown object for a large experiment, this function may run slowly and 
#' use a large amount of RAM. We recommend running this constructor as a batch job and saving the 
#' resulting ballgown object as an rda file.  The rda file usually has reasonable size on disk, and 
#' the object in it shouldn't take up too much RAM when loaded, so the time and memory use in 
#' creating the object is a one-time cost.
#' 
#' @return a \code{\link{ballgown}} object
#' 
#' @author Leonardo Collado Torres, Alyssa Frazee
#' 
#' @rdname ballgown-constructor
#' 
#' @export
ballgown = function(samples=NULL, dataDir=NULL, samplePattern=NULL, bamfiles = NULL, pData = NULL, 
    verbose=TRUE, ...){
    if(verbose) message(date())

    if(all(c(is.null(samples),is.null(dataDir),is.null(samplePattern)))){
        stop("must provide either \"samples\" or both \"dataDir\" and \"samplePattern\"")
    }

    ## Determine where data is located
    if(is.null(samples)){
        if(is.null(samplePattern)|is.null(dataDir)) stop("must provide both \"dataDir\" and 
            \"samplePattern\" if \"samples\" is NULL.")
        samples <- list.files(path=dataDir, pattern=samplePattern, full.names=TRUE)
        names(samples) <- list.files(path=dataDir, pattern=samplePattern)
    }else{
        names(samples) = sapply(samples, function(x){
            tail(strsplit(x, split="/")[[1]],n=1)
        }, USE.NAMES=FALSE)
    }

    ## check to see if you actually have ballgown data:
    n <- length(samples)
    subfiles = list.files(samples)
    ctabs = subfiles[subfiles %in% 
        c('e_data.ctab', 'i_data.ctab', 't_data.ctab', 'e2t.ctab', 'i2t.ctab')]
    if(length(ctabs) != 5*n){
        stop("something is wrong: are you missing .ctab files? do extra files/folders (other than 
            tablemaker output folders) match your samples/dataDir/samplePattern argument(s)?")
    }

    ## Read tables linking exons/introns to transcripts
    if(verbose) message(paste0(date(), ": Reading linking tables"))
    e2t <- read.table(list.files(samples[1], "e2t.ctab", full.names=TRUE), 
        header=TRUE, sep="\t", colClasses=c("integer", "integer"))
    i2t <- read.table(list.files(samples[1], "i2t.ctab", full.names=TRUE), 
        header=TRUE, sep="\t", colClasses=c("integer", "integer"))

    ## Order by transcript id
    e2t <- e2t[order(e2t$t_id), ]
    i2t <- i2t[order(i2t$t_id), ]
    rownames(e2t) <- 1:nrow(e2t)
    rownames(i2t) <- 1:nrow(i2t)

    ## Read counts for all introns 
    if(verbose) message(paste0(date(), ": Reading intron data files"))
    intronFiles <- sapply(samples, list.files, pattern="i_data.ctab", full.names=TRUE)
    intronAll <- lapply(intronFiles, .readIntron)

    ## Merge the intron results
    if(verbose) message(paste0(date(), ": Merging intron data"))
    #[ensure ctab files all contain same introns]
    sumdiff <- sapply(intronAll, function(x) sum(x$i_id != intronAll[[1]]$i_id))
    if(!(all(sumdiff==0))){
        stop('intron ids were either not the same or not in the same order across samples. 
            double check i_data.ctab for each sample.')
    }
    idataOnly <- lapply(intronAll[2:length(intronAll)], function(x) x[,6:ncol(x)]);
    intron <- data.frame(intronAll[[1]], as.data.frame(idataOnly))
    colnames(intron)  <- c("i_id", "chr", "strand", "start", "end", 
        paste(c("rcount", "ucount", "mrcount"), rep(names(samples), each=3), sep="."))

    ## Make intron data into GRanges object
    #A. fix strand information for compatibility w/ GRanges
    intron$strand = as.character(intron$strand)
    intron$strand[intron$strand=="."] <- "*"
    #B. get names of transcripts each intron belongs to
    tnamesin = split(i2t$t_id, i2t$i_id)
    tnamesin.ord = as.character(tnamesin)[match(intron$i_id, names(tnamesin))]
    #C. make the GRanges object
    introngr = GRanges(seqnames=Rle(intron$chr), ranges=IRanges(start=intron$start, end=intron$end),
        strand = Rle(intron$strand), id=intron$i_id, transcripts = tnamesin.ord)

    ## Read exon data
    if(verbose) message(paste0(date(), ": Reading exon data files"))
    exonFiles <- sapply(samples, list.files, pattern="e_data.ctab", full.names=TRUE)
    exonAll <- lapply(exonFiles, .readExon)

    ## Merge the exon results
    if(verbose) message(paste0(date(), ": Merging exon data"))
    #[ensure ctab files all contain same exons]
    sumdiffex <- sapply(exonAll, function(x) sum(x$e_id != exonAll[[1]]$e_id))
    if(!(all(sumdiffex==0))){
        stop('exon ids were either not the same or not in the same order across samples. 
            double check e_data.ctab for each sample.')
    }
    edataOnly <- lapply(exonAll[2:length(exonAll)], function(x) x[,6:ncol(x)])
    exon <- data.frame(exonAll[[1]], as.data.frame(edataOnly))
    colnames(exon) <- c("e_id", "chr", "strand", "start", "end", 
        paste(c("rcount", "ucount", "mrcount", "cov", "cov_sd", "mcov", "mcov_sd"), 
            rep(names(samples), each=7), sep="."))

    ## Make exon data into GRanges object
    #A. fix strand information for compatibility w/ GRanges
    exon$strand = as.character(exon$strand)
    exon$strand[exon$strand=="."] <- "*"
    #B. get names of transcripts each exon belongs to
    tnamesex = split(e2t$t_id, e2t$e_id)
    #C. make the GRanges object
    tnamesex.ord = as.character(tnamesex)[match(exon$e_id, names(tnamesex))]
    exongr = GRanges(seqnames=Rle(exon$chr), ranges=IRanges(start=exon$start, end=exon$end), 
        strand=Rle(exon$strand), id=exon$e_id, transcripts=tnamesex.ord)

    ## Read transcript data
    if(verbose) message(paste0(date(), ": Reading transcript data files"))
    transFiles <- sapply(samples, list.files, pattern="t_data.ctab", full.names=TRUE)
    transAll <- lapply(transFiles, .readTrans)

    ## Merge transcript results
    if(verbose) message(paste0(date(),": Merging transcript data"))
    #[ensure ctab files all contain same transcripts]
    sumdifft <- sapply(transAll, function(x) sum(x$t_id != transAll[[1]]$t_id))
    if(!(all(sumdifft==0))){
        stop('transcript ids were either not the same or not in the same order across samples. 
            double check t_data.ctab for each sample.')
    }
    tdataOnly <- lapply(transAll[2:length(transAll)], function(x) x[,11:ncol(x)])
    trans <- data.frame(transAll[[1]], as.data.frame(tdataOnly))
    colnames(trans) <- c("t_id", "chr", "strand", "start", "end", "t_name", "num_exons", "length", 
        "gene_id", "gene_name", paste(c("cov", "FPKM"), rep(names(samples), each=2), sep="."))

    ## Make transcripts into a GRanges list object
    mm = match(e2t$e_id, mcols(exongr)$id)
    if(any(is.na(mm))){
        warning(paste('the following exon(s) did not appear in e_data.ctab:',
        paste(e2t$e_id[which(is.na(mm))], collapse=", ")))
    }
    transgrl = split(exongr[mm[!is.na(mm)]], e2t$t_id[!is.na(mm)])

    ## Connect transcripts to genes:
    t2g = data.frame(t_id = trans$t_id, g_id = trans$gene_id)

    ## Read phenotype table, if given:
    if(is.character(pData)){
        if(verbose) message(paste0(date(),": Reading phenotype table"))
        phx = read.table(pData, stringsAsFactors=FALSE, ...)
        theorder = sapply(names(samples), function(x) which(phx[,1]==x))
        phx = phx[theorder,]
        meastypes = ss(colnames(trans)[-c(1:10)], pattern="\\.", slot=1)
        column_order = ss(colnames(trans)[-c(1:10)], pattern="\\.", slot=2)[meastypes=="FPKM"]
        if(!all(phx[,1] == column_order)){
            warning('the rows of pData did not seem to be in the same order as the columns of the 
                expression data. attempting to rearrange pData.')
            tmp = try(phx <- phx[,match(column_order, phx[,1])])
            if(class(tmp) == "try-error"){
                stop('first column of pData does not match the names of the folders containing the 
                    ballgown data.')
            }
        }
    }else if(is.data.frame(pData)){
        phx = pData
        meastypes = ss(colnames(trans)[-c(1:10)], pattern="\\.", slot=1)
        column_order = ss(colnames(trans)[-c(1:10)], pattern="\\.", slot=2)[meastypes=="FPKM"]
        if(!all(phx[,1] == column_order)){
            warning('the rows of pData did not seem to be in the same order as the columns of the 
                expression data. attempting to rearrange pData.')
            tmp = try(phx <- phx[,match(column_order, phx[,1])])
            if(class(tmp) == "try-error"){
                stop('first column of pData does not match the names of the folders containing the 
                    ballgown data.')
            }
        }
    }
    if(is.null(pData)) phx = NULL

    if(verbose) message("Wrapping up the results")
    result <- new("ballgown", data=list(intron=intron, exon=exon, trans=trans), 
        indexes=list(e2t=e2t, i2t=i2t, t2g=t2g, bamfiles=bamfiles, pData=phx), 
        structure=list(intron=introngr, exon=exongr, trans=transgrl), 
        dirs=samples, mergedDate=date())

    if(verbose) message(date())
    return(result)
}

