#' Ballgown
#'
#' S4 class for storing and manipulating expression data from assembled transcriptomes
#'
#' @aliases Ballgown
#' @slot data tables containing expression data for genomic features (introns, exons, transcripts)
#' @slot structure genomic locations of features and their relationships to one another
#' @slot indexes tables connecting components of the assembly and providing other experimental information (e.g., phenotype data and locations of read alignment files)
#' @slot dirs directories holding data created by \code{tablemaker}
#' @slot mergedDate date the ballgown object was created
#' @name ballgown-class
#' @rdname ballgown-class
#' @exportClass ballgown
#' @import methods
#' @import RColorBrewer
#' @import DESeq
#' @import matrixStats
#' @import splines
#' @importFrom sva f.pvalue
#' @importFrom plyr join_all
#' @author Alyssa Frazee, Leonardo Collado Torres, Jeff Leek
setClass("ballgown", 
    representation(
        data = "list",           # coverage data
        indexes = "list",        # reference information
        structure = "list",      # assembly information
        dirs = "character",      # directories where ballgown data is stored
        mergedDate = "character" # date the object was created
	)
)

### constructor, authors: Leonardo Collado Torres & Alyssa Frazee
### a couple helper functions:
.readIntron <- function(file){
  intron <- read.table(file, header=TRUE, sep="\t", colClasses=c("integer", "character", "factor", "integer", "integer", "integer", "integer", "numeric"))
  intron <- intron[order(intron$i_id), ]
  rownames(intron) <- 1:nrow(intron)
  return(intron)
}

.readExon <- function(file) {
  exon <- read.table(file, header=TRUE, sep="\t", colClasses=c("integer", "character", "factor", "integer", "integer", "integer", "integer", "numeric", "numeric", "numeric", "numeric", "numeric"))
  exon <- exon[order(exon$e_id), ]
  rownames(exon) <- 1:nrow(exon)
  return(exon)
}

.readTrans <- function(file) {
  trans <- read.table(file, header=TRUE, sep="\t", colClasses=c("integer", "character", "factor", "integer", "integer", "character", "integer", "integer", "character", "character", "numeric", "numeric"))
  trans <- trans[order(trans$t_id), ]
  rownames(trans) <- 1:nrow(trans)
  return(trans)
}

#' constructor function for ballgown objects
#'
#' @param dirs vector of file paths to folders containing sample-specific ballgown data (generated by \code{tablemaker}).  If \code{dirs} is provided, \code{dataDir} and \code{samplePattern} are not used.
#' @param dataDir file path to top-level directory containing sample-specific folders with ballgown data in them.  Only used if \code{dirs} is NULL.
#' @param samplePattern regular expression identifying the subdirectories of \code{dataDir} containing data to be loaded into the ballgown object (and only those subdirectories).  Only used if \code{dirs} is NULL.
#' @param bamfiles optional vector of file paths to read alignment files for each sample.  If provided, make sure to sort properly (e.g., in the same order as \code{dirs}).  Default NULL.
#' @param pData either a \code{data.frame} with rows corresponding to samples and columns corresponding to phenotypic variables, or a path to a file containing phenotype data.
#' @param verbose if \code{TRUE}, print status messages and timing information as the object is constructed.
#' @param ... extra arguments for \code{read.table}, if \code{pData} is a path to a file.
#' @details Because experimental data is recorded so variably, it is the user's responsibility to format \code{pData} correctly.  In particular, it's really important that the rows of \code{pData} (corresponding to samples) are ordered the same way as \code{dirs} or the \code{dataDir}/\code{samplePattern} combo.  You can run \code{file.path(path = dataDir, pattern = samplePattern)} to see the sample order if \code{dirs} was not used.
#' 
#' If you are creating a ballgown object for a large experiment, this function may run slowly and use a large amount of RAM. We recommend running this constructor as a batch job and saving the resulting ballgown object as an rda file.  The rda file usually has reasonable size on disk, and the object in it shouldn't take up too much RAM when loaded, so the time and memory use in creating the object is a one-time cost.
#' @return a \code{\link{ballgown}} object
#' @author Leonardo Collado Torres, Alyssa Frazee
#' @export
ballgown = function(dirs=NULL, dataDir=NULL, samplePattern=NULL, bamfiles = NULL, pData = NULL, verbose=TRUE, ...) {
    if(verbose) message(date())

    if(all(c(is.null(dirs),is.null(dataDir),is.null(samplePattern)))) stop("must provide either dirs or both dataDir and samplePattern")

    ## Determine where data is located
    if(is.null(dirs)){
        if(is.null(samplePattern)|is.null(dataDir)) stop("must provide both dataDir and samplePattern if dirs is NULL.")
        dirs <- list.files(path=dataDir, pattern=samplePattern, full.names=TRUE)
        names(dirs) <- list.files(path=dataDir, pattern=samplePattern)
    }else{
        names(dirs) = sapply(dirs, function(x){
        tail(strsplit(x, split="/")[[1]],n=1)
        }, USE.NAMES=FALSE)
    }

    n <- length(dirs)

    ## Read tables linking exons/introns to transcripts
    if(verbose) message(paste0(date(), ": Reading linking tables"))
    e2t <- read.table(list.files(dirs[1], "e2t.ctab", full.names=TRUE), header=TRUE, sep="\t", colClasses=c("integer", "integer"))
    i2t <- read.table(list.files(dirs[1], "i2t.ctab", full.names=TRUE), header=TRUE, sep="\t", colClasses=c("integer", "integer"))

    ## Order by transcript id
    e2t <- e2t[order(e2t$t_id), ]
    i2t <- i2t[order(i2t$t_id), ]
    rownames(e2t) <- 1:nrow(e2t)
    rownames(i2t) <- 1:nrow(i2t)

    ## Read counts for all introns 
    if(verbose) message(paste0(date(), ": Reading intron data files"))
    intronFiles <- sapply(dirs, list.files, pattern="i_data.ctab", full.names=TRUE)
    intronAll <- lapply(intronFiles, .readIntron)

    ## Merge the intron results
    if(verbose) message(paste0(date(), ": Merging intron data"))
    intron <- join_all(intronAll, by=c("i_id", "chr", "strand", "start", "end"), type="left")
    colnames(intron)  <- c("i_id", "chr", "strand", "start", "end", paste(c("rcount", "ucount", "mrcount"), rep(names(dirs), each=3), sep="."))

    ## Make intron data into GRanges object
    #A. fix strand information for compatibility w/ GRanges
    intron$strand = as.character(intron$strand)
    intron$strand[intron$strand=="."] <- "*"
    #B. get names of transcripts each intron belongs to
    tnamesin = split(i2t$t_id, i2t$i_id)
    tnamesin.ord = as.character(tnamesin)[match(intron$i_id, names(tnamesin))]
    #C. make the GRanges object
    introngr = GRanges(seqnames = Rle(intron$chr), ranges = IRanges(start=intron$start, end=intron$end), strand = Rle(intron$strand), id=intron$i_id, transcripts = tnamesin.ord)

    ## Read exon data
    if(verbose) message(paste0(date(), ": Reading exon data files"))
    exonFiles <- sapply(dirs, list.files, pattern="e_data.ctab", full.names=TRUE)
    exonAll <- lapply(exonFiles, .readExon)

    ## Merge the exon results
    if(verbose) message(paste0(date(), ": Merging exon data"))
    exon <- join_all(exonAll, by=c("e_id", "chr", "strand", "start", "end"), type="left")
    colnames(exon) <- c("e_id", "chr", "strand", "start", "end", paste(c("rcount", "ucount", "mrcount", "cov", "cov_sd", "mcov", "mcov_sd"), rep(names(dirs), each=7), sep="."))

    ## Make exon data into GRanges object
    #A. fix strand information for compatibility w/ GRanges
    exon$strand = as.character(exon$strand)
    exon$strand[exon$strand=="."] <- "*"
    #B. get names of transcripts each exon belongs to
    tnamesex = split(e2t$t_id, e2t$e_id)
    #C. make the GRanges object
    tnamesex.ord = as.character(tnamesex)[match(exon$e_id, names(tnamesex))]
    exongr = GRanges(seqnames = Rle(exon$chr), ranges = IRanges(start=exon$start, end=exon$end), strand = Rle(exon$strand), id=exon$e_id, transcripts = tnamesex.ord)

    ## Read transcript data
    if(verbose) message(paste0(date(), ": Reading transcript data files"))
    transFiles <- sapply(dirs, list.files, pattern="t_data.ctab", full.names=TRUE)
    transAll <- lapply(transFiles, .readTrans)

    ## Merge transcript results
    if(verbose) message(paste0(date(),": Merging transcript data"))
    trans <- join_all(transAll, by=c("t_id", "chr", "strand", "start", "end", "t_name", "num_exons", "length", "gene_id", "gene_name"), type="left")
    colnames(trans) <- c("t_id", "chr", "strand", "start", "end", "t_name", "num_exons", "length", "gene_id", "gene_name", paste(c("cov", "FPKM"), rep(names(dirs), each=2), sep="."))

    ## Make transcripts into a GRanges list object
    mm = match(e2t$e_id, mcols(exongr)$id)
    if(any(is.na(mm))){
        warning(paste('the following exon(s) did not appear in e_data.ctab:',
        paste(e2t$e_id[which(is.na(mm))], collapse=", ")))
    }
    transgrl = split(exongr[mm[!is.na(mm)]], e2t$t_id[!is.na(mm)])
    names(transgrl) = paste0("tx", names(transgrl))

    ## Connect transcripts to genes:
    t2g = data.frame(t_id = trans$t_id, g_id = trans$gene_id)

    ## Read phenotype table, if given:
    if(is.character(pData)){
        if(verbose) message(paste0(date(),": Reading phenotype table"))
        phx = read.table(pData, stringsAsFactors=FALSE, ...)
        theorder = sapply(names(dirs), function(x) which(phx$dirname==x))
        phx = phx[theorder,]
        }
    if(is.data.frame(pData)) phx = pData
    if(is.null(pData)) phx = NULL

    if(verbose) message("Wrapping up the results")
    result <- new("ballgown", data = list(intron=intron, exon=exon, trans=trans), indexes=list(e2t=e2t, i2t=i2t, t2g=t2g, bamfiles = bamfiles, pData = phx), structure = list(intron = introngr, exon = exongr, trans = transgrl), dirs=dirs, mergedDate=date())

    if(verbose) message(date())
    return(result)
}

### define generics
# generic function definitions for the ballgown class

#' methods for objects of class \code{ballgown}
#'
#' The following methods are available for the S4 class \code{ballgown}.
#' @name ballgown-methods
#' @aliases structure
#' @export
#' @docType methods
#' @rdname ballgown-methods
#' @param x ballgown object
#' @return for \code{structure}: list containing elements \code{intron} (GRanges), \code{exon} (GRanges), and \code{trans} (GRangesList), denoting genomic positions of exons, introns, and transcripts (represented as sets of exons).
setGeneric("structure", function(x) standardGeneric("structure"))

#' @name data
#' @export
#' @docType methods
#' @rdname ballgown-methods
#' @return for \code{data}: list containing elements \code{intron}, \code{exon}, and \code{trans} (all data frames) -- feature-by-sample expression tables.
setGeneric("data", function(x) standardGeneric("data"))

#' @name indexes
#' @export
#' @docType methods
#' @rdname ballgown-methods
#' @return for \code{indexes}: list containing elements \code{e2t}, \code{i2t}, \code{t2g}, \code{bamfiles}, and \code{pData}, where \code{e2t} and \code{i2t} are data frames linking exons and introns (respectively) to transcripts, \code{t2g} is a data frame linking transcripts to genes, and \code{bamfiles} and \code{pData} are described at the \code{link{ballgown}} constructor help page.
setGeneric("indexes", function(x) standardGeneric("indexes"))

#' @name dirs
#' @export
#' @docType methods
#' @rdname ballgown-methods
#' @return for \code{dirs}: paths to the on-disk directories holding the data (created with \code{tablemaker}) used to create \code{x}
setGeneric("dirs", function(x) standardGeneric("dirs"))

#' @name mergedDate
#' @export
#' @docType methods
#' @rdname ballgown-methods
#' @return for \code{mergedDate}: the date \code{x} was created
setGeneric("mergedDate", function(x) standardGeneric("mergedDate"))

#' @name indexes<-
#' @export
#' @docType methods
#' @rdname ballgown-methods
#' @param value the updated value for a ballgown object component
setGeneric("indexes<-", function(x, value) standardGeneric("indexes<-"))

#' @name data<-
#' @export
#' @docType methods
#' @rdname ballgown-methods
setGeneric("data<-", function(x, value) standardGeneric("data<-"))

#' @name subset
#' @export
#' @docType methods
#' @rdname ballgown-methods
setGeneric("subset", function(x) standardGeneric("subset"))

#' @name pData
#' @export
#' @docType methods
#' @rdname ballgown-methods
setGeneric("pData", function(x) standardGeneric("pData"))

#' @name pData<-
#' @export
#' @docType methods
#' @rdname ballgown-methods
setGeneric("pData<-", function(x, value) standardGeneric("pData<-"))

#' @name texpr
#' @export
#' @docType methods
#' @rdname ballgown-methods
#' @param ... for \code{subset}: logical expression involving any column of the \code{texpr} dictating what subset of \code{x} is desired.  For \code{*expr} methods: one of \code{'cov'}, \code{'FPKM'}, \code{'rcount'}, \code{'ucount'}, \code{'mrcount'}, \code{'cov_sd'}, \code{'mcov'}, or \code{'mcov_sd'}, depending on which type of expression measurement is desired.  Leave \code{...} blank to select all expression measurements.
setGeneric("texpr", function(x, ...) standardGeneric("texpr"))

#' @name eexpr
#' @export
#' @docType methods
#' @rdname ballgown-methods
setGeneric("eexpr", function(x, ...) standardGeneric("eexpr"))

#' @name iexpr
#' @export
#' @docType methods
#' @rdname ballgown-methods
setGeneric("iexpr", function(x, ...) standardGeneric("iexpr"))

#' @name gexpr
#' @export
#' @docType methods
#' @rdname ballgown-methods
#' @return for \code{*expr} methods: a feature-by-sample table with the specified expression measurement in the cells, or all possible expression measurements if none was specified.
setGeneric("gexpr", function(x) standardGeneric("gexpr"))




